//
// Created by 宋晓奎 on 2023/12/19.
//

#include "compiler.h"

const string MY_NAME = "sss";
static string MY_NAME_2 = "aaa";
string MY_NAME_3 = "sxk";

void Compiler(void) {
    cout << "This is compile file ." << endl;
    // 程序拆分三部分
    // 头文件: 包含结构的声明和函数原型
    // 源代码文件: 包含与结构有关的函数的代码
    // 源代码文件: 包含调用与结构相关的函数的代码

    // 注意: 不要将函数定义(函数实现)和变量声明放到头文件中
    // 头文件中包括的内容:
    //      函数原型
    //      使用宏define定义或const定义的符号常量
    //      结构声明
    //      类声明
    //      模版声明
    //      内联函数

    // 使用预处理指令#include时 需要注意下面两点
    //  1. 如果文件名在<>内部 则C++编译器将在存储标准头文件的主机系统的文件系统中查找
    //  2. 如果时自定义的头文件 则使用""包裹引入的头文件名称即可 编译器首先查找当前工作目录或源代码目录

    // 预处理指令
    // #define
    // #ifndef #endif
    cout << SXK << endl;
    cout << sxk << endl;

    // 翻译单元
    // 名称修饰: 在C++中，函数名和变量名在编译后会发生名称修饰，这是为了支持函数重载和命名空间的特性，用来区分编译后不同的函数或变量

    // C++存储模式
    // 自动存储持续性: 在函数内部声明的变量、函数参数的存储位自动(随函数调用而分配内存 函数执行结束 内存释放)
    // 静态存储持续性: 在函数外定义的全局变量 和使用关键词static定义的变量，或使用const定义的全局常量 在程序整个运行过程中都存在
    // 线程存储持续性: 在多核处理器上，使用thread_local声明,其生命周期和所属线程一样长
    // 动态存储持续性: 使用new运算符分配的内存一直存在，直到使用delete运算符将其释放或程序结束 （自由存储 堆存储）

    // 作用域
    // scope 描述的名称在文件(翻译单元)的范围可见性

    // 链接性
    // linkage 描述了名称如何在不同文件(翻译单元)间共享
    // 链接性为外部的名称可以在文件间共享
    // 链接性为内部的名称只能在一个文件内共享
    // 自动变量的名称没有链接性 所以不能共享

    {
        int a = 1;
        cout << "局部代码块: " << a << endl;
    }
    // cout << a << endl; // error 局部外不可见

    // 综上: C++存储方式是通过存储连续性、作用域、链接性描述

    // auto现在都在后置类型推断中使用
    // 在C以前老版本用来指定自动变量
    int auo = 1;
    cout << "Out a address: " << &auo << endl;
    {
        // use auto 创建自动变量
        // auto int auo = 100;
        cout << "Inner a address: " << &auo << endl;
    }
    cout << "auo: " << auo << endl;

    // 自动变量的初始化
    // 可以使用任何在声明时其值为已知的表达式来初始化自动变量

    // 自动变量与栈
    // 程序执行时有两个栈帧 一个栈底 一个栈顶
    // 调用函数时 将参数按顺序押入栈顶 栈顶指针按类型移动
    // 然后将押入栈的数据与形参关联
    // 当在函数内执行遇到自动变量 栈顶继续移动分配内存
    // 程序执行结束 栈顶指针回到函数调用处 等于释放内存

    // 寄存器变量
    // 关键词register定义 它建议编译器使用CPU寄存器来存储自动变量
    // 目的是为了提高访问变量的速度
}